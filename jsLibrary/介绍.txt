/*
1.所有的引用类型 （数组，函数，对象）可以自由扩展属性(Null除外);

2.所有的引用类型都有个 __proto__属性（隐式原型，本身也是一个普通的对象）

3.所有的函数都有一个prototype属性 (显示原型)，prototype是函数独有都

4.所有的引用类型 __proto__属性指向他的构造函数 prototoype  属性

5.当试图得到一个对象的属性的时候，如果这个对象本身不存在这个属性，它会去__proto__属性

我们一个原型链的理论
*/

/*修改html原生
破坏了原声的对象结果，不建议使用

数据

sum 求和

导致对象结构的污染，所以一般不建议大家去修改原声的对象结构

*/

1.我们为了避免资源浪费
css()
这样造成了内存的浪费
->原型
原型链
->
原型链上的添加方法，会造成原生对象结构的一个污染
->自义定一个原型，通过子一定原型上去添加方法，这样是不是就避免了破坏原生的一个机构，内存的浪费

->$('div').element[0]
我们的div都放在我们的fn一个对象的elements属性上面
$('div')[0]

js库 js LiBrary
每拿到一个选择
都会添加一个css方法
内存里面就存在很多css方法

我有100个css选择器，我去调用了css方法
是不是很浪费内存资源

在原型上添加我们的方法
HTMLCollection.prototype.css=function(){}
破坏了原声的原型独享的一个结构
Array sum()
大家在开发中一定要注意，不要破坏原生的原型对象的结构，会造成原声对象的结构污染

return element

自义定一个对象，element添加到我们的自义定Fn对象上的elements属性上
$('div').elements[0] 取值麻烦

1.我们自己定义了一个$作为入口函数,传入我们的标签
2.标签传到了我们呢的Library，接受我们的标签，返回一个Fn实例
3.根据标签去获取页面中的所有的元素
4.所有的元素放到了Fn对象本身，不放到Fn的elements属性上面
5.修改对象原型，把一些DOM操作放到原型中去